/**
 * Low-level interface wrapped around ogg/vorbis/theora libraries
 * cross-compiled with emscripten.
 *
 * Used by the high-level player interface.
 *
 * @author Brion Vibber <brion@pobox.com>
 * @copyright 2013-2014
 * @license MIT-style
 */
CODEC_CLASS = (function(options) {
	var ident = ++CODEC_CLASS.instanceCount;
	var self = this;

    var Module = {
    	noInitialRun: true,
    	noExitRuntime: true,
    	TOTAL_MEMORY: 32 * 1024 * 1024, // default heap is 16M
    	print: function(str) {
    		console.log("Codec" + ident + ": " + str);
    	}
    };

	#include CODEC_TARGET

    var codecjs_init = Module.cwrap('codecjs_init', 'void', ['number', 'number']);
    var codecjs_destroy = Module.cwrap('codecjs_destroy', 'void', []);
    var codecjs_receive_input = Module.cwrap('codecjs_receive_input', 'void', ['number', 'number']);
    var codecjs_process = Module.cwrap('codecjs_process', 'number', []);
    var codecjs_decode_frame = Module.cwrap('codecjs_decode_frame', 'number', []);
    var codecjs_decode_audio = Module.cwrap('codecjs_decode_audio', 'number', []);
    var codecjs_flush_buffers = Module.cwrap('codecjs_flush_buffers', 'void', []);
    var codecjs_discard_frame = Module.cwrap('codecjs_discard_frame', 'void', []);
    var codecjs_discard_audio = Module.cwrap('codecjs_discard_audio', 'void', []);
    var codecjs_media_length = Module.cwrap('codecjs_media_length', 'number', []);
    var codecjs_media_duration = Module.cwrap('codecjs_media_duration', 'number');
    var codecjs_keypoint_offset = Module.cwrap('codecjs_keypoint_offset', 'number', ['number']);

	var inputBuffer, inputBufferSize;
	function reallocInputBuffer(size) {
		if (inputBuffer && inputBufferSize >= size) {
			// We're cool
			return inputBuffer;
		}
		if (inputBuffer) {
			Module._free(inputBuffer);
		}
		inputBufferSize = size;
		inputBuffer = Module._malloc(inputBufferSize);
		return inputBuffer;
	}

	// Internal variables backing properties...
	var loadedMetadata = false,
		duration = NaN,
		videoFormat = null,
		frameReady = false,
		frameBuffer = null,
		frameTimestamp = 0,
		keyframeTimestamp = 0,
		audioFormat = null,
		audioReady = false,
		audioBuffer = null,
		audioTimestamp = 0;

	// - Internal callbacks

	function ogvjsLoadedMetadataCallback() {
		loadedMetadata = true;
		var len = codecjs_media_duration();
		if (len >= 0) {
			duration = len;
		} else {
			duration = NaN;
		}
	}

	function ogvjsInitVideoCallback(info) {
		videoFormat = info;
	}

	function ogvjsOutputFrameReadyCallback(aFrameTimestamp, aKeyframeTimestamp) {
		frameReady = true;
		frameTimestamp = aFrameTimestamp;
		keyframeTimestamp = aKeyframeTimestamp;
	}

	function ogvjsFrameCallback(buffer) {
		frameBuffer = buffer;
	}

	function ogvjsInitAudioCallback(info) {
		audioFormat = info;
	}

	function ogvjsOutputAudioReadyCallback(aAudioTimestamp) {
		audioReady = true;
		audioTimestamp = aAudioTimestamp;
	}

	function ogvjsAudioCallback(buffer) {
		audioBuffer = buffer;
	}

	// - Property getters

	/**
	 * Are we in the middle of an asynchronous processing operation?
	 * @property boolean
	 */
	Object.defineProperty(self, 'processing', {
		get: function getProcessing() {
			return false;
		}
	});

	Object.defineProperty(self, 'loadedMetadata', {
		get: function getLoadedMetadata() {
			return loadedMetadata;
		}
	});

	/**
	 * Duration of segment in seconds, if defined in Ogg Skeleton metadata,
	 * else NaN
	 *
	 * @property number
	 */
	Object.defineProperty(self, 'duration', {
		get: function getDuration() {
			return duration;
		}
	});

	Object.defineProperty(self, 'hasVideo', {
		get: function getHasVideo() {
			return !!videoFormat;
		}
	});

	Object.defineProperty(self, 'videoFormat', {
		get: function getVideoFormat() {
			// @todo copy?
			return videoFormat;
		}
	});

	Object.defineProperty(self, 'hasAudio', {
		get: function getHasAudio() {
			return !!audioFormat;
		}
	});
	Object.defineProperty(self, 'audioFormat', {
		get: function getAudioFormat() {
			// @todo copy?
			return audioFormat;
		}
	});

	/**
	 * @property boolean Have we found a frame that's ready to be decoded?
	 */
	Object.defineProperty(self, 'frameReady', {
		get: function getFrameReady() {
			return frameReady;
		}
	});

	/**
	 * @property boolean Have we found an audio buffer that's ready to be decoded?
	 */
	Object.defineProperty(self, 'audioReady', {
		get: function getAudioReady() {
			return audioReady;
		}
	});

	/**
	 * @property number time position in seconds of last decoded frame
	 */
	Object.defineProperty(self, 'frameTimestamp', {
		get: function getFrameTimestamp() {
			return frameTimestamp;
		}
	});

	Object.defineProperty(self, 'keyframeTimestamp', {
		get: function getKeyframeTimestamp() {
			return keyframeTimestamp;
		}
	});	

	/**
	 * Return the last-decoded frame, if any.
	 *
	 * @return Object {yBytes, cbBytes, crBytes, yStride, cbStride, crStride, width, height, hdec, vdec, timestamp}
	 */
	Object.defineProperty(self, 'frameBuffer', {
		get: function getFrameBuffer() {
			return frameBuffer;
		}
	});

	Object.defineProperty(self, 'audioTimestamp', {
		get: function getAudioTimestamp() {
			return audioTimestamp;
		}
	});	

	/**
	 * Return the next decoded audio buffer
	 *
	 * @return array of audio thingies
	 */
	Object.defineProperty(self, 'audioBuffer', {
		get: function getAudioBuffer() {
			return audioBuffer;
		}
	});

	// - public methods

	self.init = function(callback) {
		codecjs_init();
		callback();
	};

	/**
	 * Tear down the instance when done.
	 */
	self.destroy = function() {
		if (inputBuffer) {
			Module._free(inputBuffer);
			inputBuffer = undefined;
		}
		codecjs_destroy();
		Module = null;
	};

	/**
	 * Queue up a chunk of input data for later processing.
	 *
	 * @param ArrayBuffer data
	 * @param function callback on completion
	 */
	self.receiveInput = function(data, callback) {
		// Map the blob into a buffer in emscripten's runtime heap
		var len = data.byteLength;
		var buffer = reallocInputBuffer(len);
		Module.HEAPU8.set(new Uint8Array(data), buffer);

		codecjs_receive_input(buffer, len);
		callback();
	};

	/**
	 * Process the next packet in the stream
	 *
	 * @param function(bool) callback on completion
	 *        takes true if still processing, false if need more data
	 */
	self.process = function(callback) {
		var ok = codecjs_process();
		callback(ok);
	};

	/**
	 * Decode the last-found video packet
	 *
	 * @param function(bool) callback on completion
	 *        takes true if successful decode, false if failure
	 */
	self.decodeFrame = function(callback) {
		if (frameReady) {
			frameReady = false;
			var ok = !!codecjs_decode_frame();
			callback(ok);
		} else {
			throw new Error("called decodeFrame when no frame ready");
		}
	};

	/**
	 * Decode the last-found audio packets
	 *
	 * @param function callback
	 *        takes true if successful decode, false if failure
	 */
	self.decodeAudio = function(callback) {
		if (audioReady) {
			audioReady = false;
			var ok = !!codecjs_decode_audio();
			callback(ok);
		} else {
			throw new Error("called decodeAudio when no audio ready");
		}
	}

	self.discardFrame = function(callback) {
		codecjs_discard_frame();
		frameReady = false;
		frameBuffer = null;
		callback();
	};

	self.discardAudio = function(callback) {
		codecjs_discard_audio();
		audioReady = false;
		audioBuffer = null;
		callback();
	};

	self.flush = function(callback) {
		codecjs_flush_buffers();
		self.discardFrame(function() {
			self.discardAudio(function() {
				callback();
			});
		});
	};

	/**
	 * Return the offset of the relevant keyframe or other position
	 * just before the given presentation timestamp
	 *
	 * @param number timeSeconds
	 * @param function(number) callback
	 *        takes the calculated byte offset
	 */
	self.getKeypointOffset = function(timeSeconds, callback) {
    	var offset = codecjs_keypoint_offset(timeSeconds * 1000);
    	callback(offset);
	};

	return self;
});
CODEC_CLASS.instanceCount = 0;
